我们可以为每个顶点添加颜色来增加图形的细节，从而创建出有趣的图像。但是，如果想让图形看起来更真实，我们就必须有足够多的顶点，从而指定足够多的颜色。这将会产生很多额外开销，因为每个模型都会需求更多的顶点，每个顶点又需求一个颜色属性。

艺术家和程序员更喜欢使用纹理（Texture）。纹理是一个 2D 图片（甚至也有 1D 和 3D 的纹理），它可以用来添加物体的细节；你可以想象纹理是一张绘有砖块的纸，无缝折叠贴合到你的 3D 的房子上。因为我们可以在一张图片上插入非常多的细节，这样就可以让物体非常精细而不用指定额外的顶点。

为了能够把纹理映射到三角形上，我们需要指定三角形的每个顶点各自对应纹理的哪个部分。这样每个顶点就会关联着一个**纹理坐标**（Texture Coordinate），用来标明该从纹理图像的哪个部分采样（采集片段颜色）。之后在图形的其它片段上进行片段插值（Fragment Interpolation）。

纹理坐标在 x 和 y 轴上，范围为 0 到 1 之间（我们使用的是 2D 纹理图像）。使用纹理坐标获取纹理颜色叫做采样（Sampling）。纹理坐标起始于 $(0, 0)$，也就是纹理图片的左下角，终于 $(1, 1)$。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。

![](_images/learnopengl-getting-started-17.png ':class=resizedImage')

```cpp
float texCoords[] = {
    0.0f, 0.0f, // 左下角
    1.0f, 0.0f, // 右下角
    0.5f, 1.0f // 上中
};
```

## 纹理环绕方式

纹理坐标的范围通常是从$(0, 0)$ 到 $(1, 1)$，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL 默认的行为是重复这个纹理图像，但 OpenGL 提供了更多的选择：

| 环绕方式             | 描述                                                                                     |
| -------------------- | ---------------------------------------------------------------------------------------- |
| `GL_REPEAT`          | 对纹理的默认行为，重复纹理图像                                                           |
| `GL_MIRRORED_REPEAT` | 和 `GL_REPEAT` 一样，但每次重复图片是镜像放置的                                          |
| `GL_CLAMP_TO_EDGE`   | 纹理坐标会被约束在 0 到 1 之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果 |
| `GL_CLAMP_TO_BORDER` | 超出的坐标为用户指定的边缘颜色                                                           |

![](_images/learnopengl-getting-started-18.png ':class=resizedImage')


## 纹理过滤

> [!DANGER]
> 前面的笔记大多都是复制教程里的文字，还不如直接看教程。笔记应该记录难点、易忘点，以大纲的形式比较好。

>当物体很大但是纹理的分辨率很低要进行纹理过滤

- **纹理像素**和**纹理坐标**：纹理坐标是给模型顶点设置的那个数组，OpenGL 以这个顶点的纹理坐标数据去查找纹理图像上的像素，然后进行采样提取纹理像素的颜色
- **临近过滤**：选择中心点最接近纹理坐标的那个像素。（偏像素风）
- **线性过滤**：一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。（更平滑）  
  ![](_images/learnopengl-getting-started-19.png ':class=resizedImage')
- **多级渐远纹理**（MipMap）：多级渐远纹理级别之间的过滤方式（有点不懂）
- 当进行放大（Magnify）和缩小（Minify）操作的时候可以设置纹理过滤选项，比如在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤：
    ```cpp
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    ```

## ⭐ 加载与创建纹理

- stb_image.h：它一个支持多种流行格式的图像加载库（纹理图像可能被储存为各种各样的格式）
- **生成纹理**的函数 `glTexImage2D`。`glGenerateMipmap` 为当前绑定的纹理自动生成所有需要的多级渐远纹理
- GLSL 内建一个 `texture` 函数来采样纹理的颜色（片段着色器内使用）
- 纹理单元（它可以让我们使用多个纹理）：一个纹理的位置值通常称为一个纹理单元，一个纹理的默认纹理单元是 0，它是默认的激活纹理单元，所以教程前面部分没有分配位置值。（看教程）
  ```cpp
  glActiveTexture(GL_TEXTURE0); // 在绑定纹理之前先激活纹理单元
  ```

> 纹理坐标和顶点坐标的坐标轴搞清楚
> 练习四看一下