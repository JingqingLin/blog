力扣<a href="https://leetcode-cn.com/problemset/2020-05/" target="_blank">每日 1 题：5 月</a>（部分）。5 月的题大部分为<font color=#ed7336>中等</font>和<font color=#ec4c47>困难</font>的题。

| 一                                                                                                                   | 二                                                                                                                     | 三                                                                                                                                                      | 四                                                                                                                        | 五                                                                                                                                                    | 六                                                                                                                                        | 日                                                                                                                                  |
| -------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------- |
| <font color=gray>27</font>                                                                                           | <font color=gray>28</font>                                                                                             | <font color=gray>29</font>                                                                                                                              | <font color=gray>30</font>                                                                                                | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/merge-two-sorted-lists" target="_blank">1 ✅</a>                                     | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters" target="_blank">2 ✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/maximum-subarray" target="_blank">3 ✅</a>                         |
| <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/jump-game-ii" target="_blank">4 ✅</a>              | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/validate-binary-search-tree" target="_blank">5 ✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/minimum-cost-for-tickets" target="_blank">6 ✅</a>                                     | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/subtree-of-another-tree" target="_blank">7 ✅</a>        | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/maximal-square" target="_blank">8 ✅</a>                                             | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/sqrtx" target="_blank">9 ✅</a>                                          | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree" target="_blank">10 ✅</a> |
| <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/powx-n" target="_blank">11 ✅</a>                   | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/min-stack" target="_blank">12 ✅</a>                  | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal" target="_blank">13 ✅</a>                           | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/single-number" target="_blank">14 ✅</a>                 | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/subarray-sum-equals-k" target="_blank">15 ✅</a>                                     | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group" target="_blank">16 ✅</a>                      | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/course-schedule-ii" target="_blank">17 ✅</a>                      |
| <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/maximum-product-subarray" target="_blank">18 ✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/valid-palindrome-ii" target="_blank">19 ✅</a>        | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts" target="_blank">20 ✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/longest-palindromic-substring" target="_blank">21 ✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal" target="_blank">22 ✅</a> | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/minimum-window-substring" target="_blank">23 ✅</a>                      | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays" target="_blank">24 ✅</a>             |
| <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/lru-cache" target="_blank">25 ✅</a>                | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/find-the-duplicate-number" target="_blank">26 ✅</a>  | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/subarray-sums-divisible-by-k" target="_blank">27 ✅</a>                                | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/decode-string" target="_blank">28 ✅</a>                 | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/house-robber" target="_blank">29 ✅</a>                                              | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram" target="_blank">30 ✅</a>                | <a style="color: #2DB55D;" href="https://leetcode-cn.com/problems/symmetric-tree" target="_blank">31 ✅</a>                          |

---

打卡完毕 🎉

---

## 1. 无重复字符的最长子串

!> [3](https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/). 无重复字符的最长子串

之前做过，👉 [传送门](leetcode/1-10?id=_3-无重复字符的最长子串)

## 2. 最大子序和

!> [53](https://leetcode-cn.com/problems/maximum-subarray/). 最大子序和

贪心思想专题做过，👉 [传送门](leetcode/贪心思想?id=_53)

## 3. 跳跃游戏 II

!> [45](https://leetcode-cn.com/problems/jump-game-ii/). 跳跃游戏 II

> 相关问题：[跳跃游戏](https://leetcode-cn.com/problems/jump-game/)

### BFS
把能跳到的位置加入队列，并维护 BFS 的层数，若最后一个点入队，返回层数

此题用 BFS 会超时，但[跳跃游戏](https://leetcode-cn.com/problems/jump-game/)中可以通过

![](_images/may-3-1.png ':class=resizedImage')

### 贪心
在[跳跃游戏](https://leetcode-cn.com/problems/jump-game/)中，只需判断是否能够跳跃到终点，那么可以这样处理这个问题：

> 依次遍历数组中的每一个位置，并**实时**维护**最远可以到达的位置**。
>
> 对于当前遍历到的位置 $x$，如果它在**最远可以到达的位置**的范围内，那么就可以从某点通过若干次跳跃到达该位置，因此可以用 $x + nums[x]$ 更新最远可以到达的位置；如果它超出了**最远可以到达的位置**，则无法到达终点。
>
> 代码如下：
> ```java
> public static boolean canJump(int[] nums) {
>     int n = nums.length;
>     int rightMost = 0;
>     for (int i = 0; i < n; ++i) {
>         if (i <= rightMost) {
>             rightMost = Math.max(rightMost, i + nums[i]);
>             if (rightMost >= n - 1) {
>                 return true;
>             }
>         } else {
>             break;
>         }
>     }
>     return false;
> }
> ```

而此题与上题唯一的不同之处是需要计算最短跳跃次数。那么需要维护一个数组，该数组记录了到达每个位置的最短跳跃次数。

如何更新最短跳跃次数的数组？假设当遍历到位置 `i` 时，最远距离 `rightMost` 被更新，那么，更新该数组 `[i + 1, rightMost]` 区间内的值，若 `cnt[i] + 1` 大于原数组的值，则不更新，见代码

```java
public int jump(int[] nums) {
    int n = nums.length;
    int rightMost = 0;
    int[] cnt = new int[n];
    for (int i = 0; i < n; ++i) {
        if (i <= rightMost) {
            if (rightMost < i + nums[i]) {
                rightMost = i + nums[i];
                for (int j = i + 1; j <= rightMost && j < n; j++) {
                    cnt[j] = cnt[j] == 0 ? cnt[i] + 1 : Math.min(cnt[i] + 1, cnt[j]);
                }
            }
            if (rightMost >= n - 1) {
                return cnt[n - 1];
            }
        } else {
            break;
        }
    }
    return 0;
}
```

## 4. 验证二叉搜索树

!> [98](https://leetcode-cn.com/problems/validate-binary-search-tree/). 验证二叉搜索树

有两种思路：
1. 根据二叉搜索树中序遍历为升序的特性来判断
2. 递归

中序遍历思路较清晰，此处对“递归法”进行解释。

对于二叉搜索树中某结点，**左子树所有节点小于它；右子树所有结点大于它**。因此递归时，设置两个参数 `upper` 和 `lower` 代表左右子树的数值区间（开区间）。

如何确定区间的值：

- 对左子树进行递归时，`lower` 不变，`upper` 变为当前结点的值
- 对右子树进行递归时，`upper` 不变，`lower` 变为当前结点的值

代码如下：

```java
public static boolean isValidBST(TreeNode root) {
    return recursion(root, Long.MIN_VALUE, Long.MAX_VALUE);
}

public static boolean recursion(TreeNode node, Long lower, Long upper) {
    if (node == null) {
        return true;
    }
    if (node.val <= lower || node.val >= upper) {
        return false;
    }
    if (!recursion(node.right, (long) node.val, upper) || !recursion(node.left, lower, (long) node.val)) {
        return false;
    }
    return true;
}
```

力扣的测试用例中，出现了 Integer 边界值的测试用例（若区间初值为 Integer 的边界值，则对于 `[2147483647]` 会返回 false），所以将左右区间范围改为 Long 的区间

## 5. ⭐ 最低票价

!> [983](https://leetcode-cn.com/problems/minimum-cost-for-tickets/). 最低票价

> 第一想法是完全背包问题，没思路，看了题解，可以从前往后 dp

$dp[i]$ 表示第 $i$ 天最便宜的花费

转移方程：

$dp[i]=\left\lbrace\begin{array}{ll} dp[i-1] && i ∉ days[] \cr \min (dp[i - 1] + cost[0], dp[i - 7] + cost[1], dp[i - 30] + cost[2]) && i ∈ days[] \end{array}\right.$  

```java
public static int mincostTickets(int[] days, int[]costs) {
    int lastDay = days[days.length - 1];
    int[] dp = new int[lastDay + 1];
    int index = 0;
    for (int i = 1; i <= lastDay; i++) {
        if (i == days[index]) {
            int day1 = i - 1;
            int day2 = Math.max(i - 7, 0);
            int day3 = Math.max(i - 30, 0);
            dp[i] = Math.min(dp[day1] + costs[0], Math.min(dp[day2] + costs[1], dp[day3] + costs[2]));
            index++;
        } else {
            // 如果这一天不是必须出行的日期，选择不买票
            dp[i] = dp[i - 1];
        }
    }
    return dp[lastDay];
}
```

## 6. 另一个树的子树

!> [572](https://leetcode-cn.com/problems/subtree-of-another-tree/). 另一个树的子树

和剑指 Offer 中 [面试题26](https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof/). 树的子结构 思路相同（但此题中的示例 2，则剑指 Offer 中是 true）

用 DFS 可实现，`isSubtree` 函数中枚举 s 中的每一个节点，判断这个点的子树是否和树 t 相等，`isSameTree` 里进行具体比较（两次 DFS）

```java
public class Solution {
    public static class TreeNode {
        int val;
        TreeNode left;
        TreeNode right;
        TreeNode(int x) {
            val = x;
        }
    }

    public static boolean isSubtree(TreeNode s, TreeNode t) {
        if (t == null) {
            return true;
        }
        if (s == null) {
            return false;
        }
        return isSameTree(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t);
    }

    private static boolean isSameTree(TreeNode s, TreeNode t) {
        if (s == null && t == null) {
            return true;
        }
        if (s == null || t == null) {
            return false;
        }
        if (s.val != t.val) {
            return false;
        }
        return isSameTree(s.left, t.left) && isSameTree(s.right, t.right);
    }
}
```

## 7. ⭐ 最大正方形

!> [221](https://leetcode-cn.com/problems/maximal-square/). 最大正方形

动态规划专题做过，👉 [传送门](leetcode/动态规划?id=_1-⭐-最大正方形)


## 8. x 的平方根

!> [69](https://leetcode-cn.com/problems/sqrtx/). x 的平方根

二分查找专题做过，👉 [传送门](leetcode/二分查找?id=_1-x-的平方根)


## 9.⭐ 二叉树的最近公共祖先

!> [236](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/). 二叉树的最近公共祖先

可以用哈希表存两条路径上的结点，若 contains 了，说明为公共结点，代码写得很烂。https://paste.ubuntu.com/p/qyYXRgQXkQ/

官方题解的两种方法都很巧妙。👍 **递归法**[题解](https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree/solution/er-cha-shu-de-zui-jin-gong-gong-zu-xian-by-leetc-2/)

## 10. Pow(x, n)

!> [50](https://leetcode-cn.com/problems/powx-n/). Pow(x, n)

直接算超时，用**快速幂**，see [题解](https://leetcode-cn.com/problems/powx-n/solution/powx-n-by-leetcode-solution/)，递归的方式实现比较直观，迭代法要想一想

## 11. 最小栈

!> [155](https://leetcode-cn.com/problems/min-stack/). 最小栈

辅助栈记录最小元素：
- 若当前 push 元素小于等于辅助栈栈顶元素，则压入辅助栈
- 若当前 pop 元素等于辅助栈栈顶元素，则弹出辅助栈

`LinkedList` 相当于双向链表，可用它来模拟队列或栈

注意：`LinkedList` 中的 `push` 是将元素插入列表的前面，压栈应该用 `addLast`

## 12. 只出现一次的数字

!> [136](https://leetcode-cn.com/problems/single-number/). 只出现一次的数字

> 本题为「[面试题56 - I](https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-lcof/). 数组中数字出现的次数」的简化版本，此题题解[传送门](leetcode/april-2020?id=_21-⭐-数组中数字出现的次数)

对于异或，我们有一个性质：$x = x \oplus y \oplus y$。那么对整个数组进行异或，最后的结果即为出现一次的数字。

## 13. 和为 K 的子数组

!> [560](https://leetcode-cn.com/problems/subarray-sum-equals-k/). 和为K的子数组

> 第一反应是排序 + 滑动窗口。仔细阅读题目后，发现要求子数组连续且数组中有负数。因此思路转向前缀和

### 枚举

以 `nums = [1, 1, 1], k = 2` 为例：

[过程动画](_media/may-2020-13-screencast.mp4 ':include :type=iframe width=100% height=500px')


```java
public static int subarraySum(int[] nums, int k) {
    int count = 0;
    for (int start = 0; start < nums.length; ++start) {
        int sum = 0;
        for (int end = start; end >= 0; --end) {
            sum += nums[end];
            if (sum == k) {
                count++;
            }
        }
    }
    return count;
}
```

时间复杂度为 $O(n^2)$

### 前缀和 + 哈希表优化

把前缀和存到哈希表里，就不用每次都加了

```java
public static int subarraySum(int[] nums, int k) {
    int count = 0, pre = 0;
    HashMap<Integer, Integer> mp = new HashMap<>();
    mp.put(0, 1);
    for (int i = 0; i < nums.length; i++) {
        pre += nums[i];
        if (mp.containsKey(pre - k)) {
            count += mp.get(pre - k);
        }
        mp.put(pre, mp.getOrDefault(pre, 0) + 1);
    }
}
```

时间复杂度为 $O(n)$

## 14. K 个一组翻转链表

!> [25](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/). K 个一组翻转链表（困难）

首先，整条链表的反转比较简单，看这里复习 👉 [传送门](https://leetcode-cn.com/problems/reverse-linked-list/)，分组链表反转的难点在于：
1. 若最后一组不满足 k 个如何不反转
2. 每组首尾如何相接

解决办法：
1. 使用快慢指针，快慢指针相差 k 个结点，若快指针为 null 说明最后一组不反转
2. 额外创建结点，记录每组的“尾巴”和下一组的“头部”，当遍历完一组后把“尾头”它们相连

代码[在此](https://paste.ubuntu.com/p/qcM6qj28BY/)

## 15. ⭐ 课程表 II

!> [210](https://leetcode-cn.com/problems/course-schedule-ii/). 课程表 II

> 考查**拓扑排序**知识，之前没做过此类题目。除拓扑排序外，有向无环图的另一个应用是关键路径

看这篇题解 👍：https://leetcode-cn.com/problems/course-schedule-ii/solution/bao-mu-shi-ti-jie-tuo-bu-pai-xu-si-lu-zen-yao-yi-2/

## 16. ⭐ 乘积最大子数组

!> [152](https://leetcode-cn.com/problems/maximum-product-subarray/). 乘积最大子数组

> 动态规划思想比较容易想到，关键在于如何处理负数的问题

参考自[官方题解](https://leetcode-cn.com/problems/maximum-product-subarray/solution/cheng-ji-zui-da-zi-shu-zu-by-leetcode-solution/)：

如果我们用 $dp_{max}$ 表示以第 $i$ 个元素**结尾**的乘积最大子数组的乘积，那么可以推出状态转移方程：

$dp_{max}[i] = \max(dp_{max}[i - 1] * nums[i], nums[i])$

求出所有的 $dp_{max}$ 之后选取最大的一个作为答案。

**可是我们发现上述方程，仅对负数个数为 0 个或 1 个的数组有效。**因为当前位置的最优解未必是由前一个位置的最优解转移得到的。比如：$nums = \{ 1, 2, -3, 4, -5 \}$，当遍历到 $-5$ 时，$-5$ 与*前一个位置结尾的乘积的*___最小值___相乘才能得到最终的答案。所以上述定义并不满足「最优子结构」。

**我们可以根据正负性进行分类讨论。**

考虑当前位置如果是一个负数的话，那么我们希望以它前一个位置结尾的某个段的积也是个负数，这样就可以负负得正，并且我们希望这个积尽可能「负得更多」，即尽可能小。如果当前位置是一个正数的话，我们更希望以它前一个位置结尾的某个段的积也是个正数，并且希望它尽可能地大。于是这里我们可以再维护一个 $dp_{min}$，它表示以第 $i$ 个元素结尾的乘积最小子数组的乘积，那么我们可以得到这样的动态规划转移方程：

$dp_{max}[i] = \max(dp_{max}[i - 1] * nums[i], dp_{min}[i - 1] * nums[i], nums[i]) \\ dp_{min}[i] = \min(dp_{max}[i - 1] * nums[i], dp_{min}[i - 1] * nums[i], nums[i])$

求出所有的 $dp_{max}$ 之后选取最大的一个作为答案。

## 17. 验证回文字符串 Ⅱ

!> [680](https://leetcode-cn.com/problems/valid-palindrome-ii/). 验证回文字符串 Ⅱ（简单）

之前做过，👉 [传送门](leetcode/双指针#_3-验证回文字符串-Ⅱ)

## 18. 💣 每个元音包含偶数次的最长子字符串

!> [1371](https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/). 每个元音包含偶数次的最长子字符串

### 前缀和 + 状态压缩

思路比较巧妙，直接看[题解](https://leetcode-cn.com/problems/find-the-longest-substring-containing-vowels-in-even-counts/solution/c-qian-zhui-he-zhuang-tai-ya-suo-xiang-jie-by-yizh/)和[代码](https://paste.ubuntu.com/p/xHHrmFBN2B/)。<font color=#8590a6>需要注意无元音字母的情况。</font>

## 19. 最长回文子串

!> [5](https://leetcode-cn.com/problems/longest-palindromic-substring/). 最长回文子串

之前做过，可以用动态规划求解，👉 [传送门](leetcode/1-10?id=_5-最长回文子串)

## 20. ⭐ 从前序与中序遍历序列构造二叉树

!> [105](https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/). 从前序与中序遍历序列构造二叉树

剑指 Offer 的原题 👉 [传送门](lcof/lcof?id=面试题07-⭐-重建二叉树)，很好地考查了树的遍历。

## 21. 最小覆盖子串

!> [76](https://leetcode-cn.com/problems/minimum-window-substring/). 最小覆盖子串（困难）

> 考查滑动窗口思想

![](_images/may-21-1.gif)

<font color=#8590a6>gif 来自[力扣题解](https://leetcode-cn.com/problems/minimum-window-substring/solution/zui-xiao-fu-gai-zi-chuan-by-leetcode-solution/)</font>

我们在 $s$ 上滑动窗口，通过移动 $r$ 指针不断扩张窗口。当窗口包含 $t$ 全部所需的字符后，如果能收缩，我们就收缩窗口直到得到最小窗口。

如何判断当前的窗口包含所有 $t$ 所需的字符呢？我们可以用一个哈希表表示 $t$ 中所有的字符以及它们的个数，用另一个哈希表动态维护窗口中所有的字符以及它们的个数，如果这个动态表中包含 $t$ 的哈希表中的所有字符，并且对应的个数都不小于 $t$ 的哈希表中各个字符的个数，那么当前的窗口是「可行」的。

[代码](https://paste.ubuntu.com/p/QCzDrbkrJ6/)

## 22. 💣 寻找两个有序数组的中位数

!> [4](https://leetcode-cn.com/problems/median-of-two-sorted-arrays/). 寻找两个有序数组的中位数（困难）

又是一道 hard，此题可以用二分思想解，之前做过，👉 [传送门](leetcode/1-10?id=_4-💣-寻找两个有序数组的中位数)

## 23. ⭐ LRU 缓存机制

!> [146](https://leetcode-cn.com/problems/lru-cache/). LRU缓存机制

此题是设计类的题目。对于 Java，可以偷懒地使用 `LinkedHashMap`，它结合了哈希表与双向链表，很方便地能实现 LRU（[代码](https://paste.ubuntu.com/p/gjX6R7Cf6N/)），但这并没有达到题目的考查目的。

此题应该使用哈希表辅以双向链表的方法来实现，由于双向链表结构比较简单，我们可以自行封装。

> [!TIP]
> 在双向链表的实现中，使用一个伪头部（dummy head）和伪尾部（dummy tail）标记界限，这样在添加节点和删除节点的时候就不需要检查相邻的节点是否存在。

具体实现 👉 [力扣官方题解](https://leetcode-cn.com/problems/lru-cache/solution/lruhuan-cun-ji-zhi-by-leetcode-solution/)

## 24. 🌟 寻找重复数

!> [287](https://leetcode-cn.com/problems/find-the-duplicate-number/). 寻找重复数

> [!TIP]
> 1. 不能更改原数组（假设数组是只读的）
> 2. 只能使用额外的 $O(1)$ 的空间
> 3. 时间复杂度小于 $O(n^2)$
> 4. 数组中只有一个重复的数字，但它可能不止重复出现一次

> 题目描述符合「鸽巢原理」。鸽巢原理定义：若有 n 个笼子和 n + 1 只鸽子，所有的鸽子都被关在鸽笼里，那么至少有一个笼子有至少 2 只鸽子。


> 题目做了一些限制，*先排序再查重*和*哈希表法*都不能使用。题解中给出了三种比较巧妙的方法：二分查找、二进制法和快慢指针。我怎么就想不到 0.0

### 二分查找

因为数组 `nums` 的数字都在 1 到 n 之间，所以以 1 和 n 作为为二分法的初始左右端点，中间数为 mid，然后统计数组 `nums` 中**小于等于**这个中间数的元素的个数 cnt，如果 cnt **大于** mid，说明重复元素在区间 `[left, mid]` 里。

以示例 1：`[1, 3, 4, 2, 2]` 为例，初始 `left = 1;right = 4;mid = 2`，统计得到，小于等于 `2` 的数有 3 个，说明重复元素在 `[1, 2]` 里。

时间复杂度为 $O(nlogn)$，👉 [代码](https://paste.ubuntu.com/p/JRjH5SgMMr/)

### 二进制

以下摘自[官方题解](https://leetcode-cn.com/problems/find-the-duplicate-number/solution/xun-zhao-zhong-fu-shu-by-leetcode-solution/)：

我们记 `nums` 数组中二进制展开后第 $i$ 位为 $1$ 的数有 $x$ 个，数字 `[1, n]` 这 $n$ 个数二进制展开后第 $i$ 位为 $1$ 的数有 $y$ 个，那么重复的数第 $i$ 位为 $1$ 当且仅当 $x>y$。

以示例 1 为例：

|           | 1   | 3   | 4   | 2   | 2   |     | $x$ | $y$ |
| --------- | --- | --- | --- | --- | --- | --- | --- | --- |
| 第 $0$ 位 | 1   | 1   | 0   | 0   | 0   |     | 2   | 2   |
| 第 $1$ 位 | 0   | 1   | 0   | 1   | 1   |     | 3   | 2   |
| 第 $2$ 位 | 0   | 0   | 1   | 0   | 0   |     | 1   | 1   |

我们发现只有第 $1$ 位 $x>y$ ，所以按位还原后 $target=(010)_2=(2)_{10}$。

正确性证明：

- 如果测试用例的数组中 $target$ 出现了两次，其余的数各出现了一次，且 $target$ 的第 $i$ 位为 $1$，那么 `nums` 数组中第 $i$ 位 $1$ 的个数 $x$ 恰好比 $y$ 大一。如果 $target$ 的第 $i$ 位为 $0$，那么两者相等。
- 如果测试用例的数组中 $target$ 出现了三次及以上，那么必然有一些数不在 `nums` 数组中了，这个时候相当于我们用 $target$ 去替换了这些数，我们考虑替换的时候对 $x$ 的影响：
    - 如果被替换的数第 $i$ 位为 $1$，且 $target$ 第 $i$ 位为 $1$：$x$ 不变，满足 $x>y$
    - 如果被替换的数第 $i$ 位为 $0$，且 $target$ 第 $i$ 位为 $1$：$x$ 加一，满足 $x>y$
    - 如果被替换的数第 $i$ 位为 $1$，且 $target$ 第 $i$ 位为 $0$：$x$ 减一，满足 $x \leq y$
    - 如果被替换的数第 $i$ 位为 $0$，且 $target$ 第 $i$ 位为 $0$：$x$ 不变，满足 $x \leq y$

也就是说如果 $target$ 第 $i$ 位为 $1$，那么每次替换后只会使 $x$ 不变或增大；如果为 $0$，只会使 $x$ 不变或减小，始终满足 $x>y$ 时 $target$ 第 $i$ 位为 $1$，否则为 $0$，因此我们只要按位还原这个重复的数即可。

时间复杂度为 $O(nlog⁡n)$，其中 $n$ 为 `nums` 数组的长度，$O(log⁡n)$ 代表了我们枚举二进制数的位数。👉 [代码](https://paste.ubuntu.com/p/vx2NbG8w5q/)。

### 快慢指针

如示例 1 中的 `[1, 3, 4, 2, 2]`，把数组索引为 0 的元素当成链表的头节点，索引为 0 的元素的值为 $1$, 表示头节点的下一个节点的索引为 1, 即数组中的 $3$。
- 再下一个节点的索引为 3, 即为第一个 $2$
- 再下一个节点的索引为 2, 即为 $4$
- 再下一个节点的索引为 4, 即为第二个 $2$
- 再下一个节点的索引为 2, 即为 $4$

此时形成了一个环。

我们设置慢指针 slow 和快指针 fast（此题中，指针的值为数组中元素的值），慢指针每次走一步，快指针每次走两步，根据「Floyd 判圈算法」两个指针在有环的情况下一定会相遇，此时我们再将 slow 放置起点，两个指针每次同时移动一步，相遇的点就是答案。

为什么后面将 slow 放置起点后移动相遇的点就一定是答案？力扣官方题解给出解释：

> 假设环长为 $L$，从起点到环的入口的步数是 $a$，从环的入口继续走 $b$ 步到达相遇位置，从相遇位置继续走 $c$ 步回到环的入口，则有 $b+c=L$，其中 > $L$、$a$、$b$、$c$ 都是正整数。根据上述定义，慢指针走了 $a+b$ 步，快指针走了 $2(a+b)$ 步。从另一个角度考虑，在相遇位置，快指针比慢指针多走了若干圈，因此快指针走的步数还可以表示成 $a+b+kL$，其中 $k$ 表示快指针在环上走的圈数。联立等式，可以得到
> 
> $$
> 2(a+b)=a+b+kL
> $$
> 
> 解得 $a=kL-ba$，整理可得
> 
> $$
> a=(k-1)L+(L-b)=(k-1)L+c
> $$
> 
> 从上述等式可知，如果慢指针从起点出发，快指针从相遇位置出发，每次两个指针都移动一步，则慢指针走了 $a$ 步之后到达环的入口，快指针在环里走了 $k-1$ 圈之后又走了 $c$ 步，由于从相遇位置继续走 $c$ 步即可回到环的入口，因此快指针也到达环的入口。两个指针在环的入口相遇，相遇点就是答案。

时间复杂度为 $O(n)$。👉 [代码](https://paste.ubuntu.com/p/fWNkw6KkFc/)。

## 25. 和可被 K 整除的子数组

!> [974](https://leetcode-cn.com/problems/subarray-sums-divisible-by-k/). 和可被 K 整除的子数组

首先想到的方法是保存所有**前缀和** sum 并对 sum 做双层循环，若 `(sum[i] - sum[j]) mod K == 0`，说明 `[j + 1, i]` 之间的元素可以被 `K` 整除，则计数加一，但这个方法超时了。那么在哪个环节可以降低复杂度呢？

显然，我们需要把内层循环“优化”掉。从判断条件入手，`(sum[i] - sum[j]) mod K == 0` 可以写成 `sum[i] mod K - sum[j] mod K == 0` 即，`sum[i] mod K = sum[j] mod K`。我们发现，只要两个前缀和取模相等，那么它们之间的元素就能被 `K` 整除，接下来只需把前缀和的取模结果作为 key，取模结果的出现次数作为 value，存入哈希表即可。

> [!TIP]
> **取模和取余的区别**
>
> 对于整型数 $a$，$b$ 来说，取模运算或者求余运算的方法都是：
> 1. 求整数商： $c = a / b$;
> 2. 计算模或者余数： $r = a - c * b$
>
> 求模运算和求余运算在第一步不同: 取余运算在取 $c$ 的值时，向 $0$ 方向舍入；而取模运算在计算 $c$ 的值时，向负无穷方向舍入。例如计算：$-7 \pmod 4$：
> 1. 求整数商 $c$，如进行求模运算 $c = -2$（向负无穷方向舍入），求余 $c = -1$（向 $0$ 方向舍入）
> 2. 计算模和余数的公式相同，但因 $c$ 的值不同，求模时 $r = 1$，求余时 $r = -3$
>
> 因此，取模的结果为非负数。本题中，前缀和可能为负数，因此需要做取模运算（在 Java 中使用 `Math.floorMod(x, y)`）

## 26. 字符串解码

!> [394](https://leetcode-cn.com/problems/decode-string/). 字符串解码

> 可能存在嵌套 `3[a2[c]]`，由此想到使用栈或递归来做


## 27. 打家劫舍

!> [198](https://leetcode-cn.com/problems/house-robber/). 打家劫舍

动态规划专题做过，👉 [传送门](leetcode/动态规划?id=_2-打家劫舍)

## 28. 💣 柱状图中最大的矩形

!> [84](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/). 柱状图中最大的矩形（困难）

乍一看和「[11](https://leetcode-cn.com/problems/container-with-most-water). 盛最多水的容器」有点像，实际上不同。直接看了[题解](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/)。

### 暴力法

- 枚举矩形的宽（比较自然能想到的方法）。可以用双重循环来固定宽度 $w$，记录一个最小高度 $h$，算出最大面积。

```java
public static int largestRectangleArea(int[] heights) {
    int maxArea = 0;
    // 枚举左端点
    for (int i = 0; i < heights.length; i++) {
        int minHeight = heights[i];
        // 枚举右端点
        for (int j = i; j < heights.length; j++) {
            int width = j - i + 1;
            minHeight = Math.min(minHeight, heights[j]);
            maxArea = Math.max(maxArea, width * minHeight);
        }
    }
    return maxArea;
}
```

- 枚举矩形的高。可以使用一重循环枚举某一根柱子，将其固定为矩形的高度 $h$。随后我们从这跟柱子开始向两侧延伸，直到遇到高度小于 $h$ 的柱子，就确定了矩形的左右边界，左右边界的宽度为 $w$。

```java
// 修改上方 for 循环
for (int mid = 0; mid < heights.length; mid++) {
    int height = heights[mid];
    int left = mid, right = mid;
    // 确定左右边界
    while (left - 1 >= 0 && heights[left - 1] >= height) {
        left--;
    }
    while (right + 1 < heights.length && heights[right + 1] >= height) {
        right++;
    }
    maxArea = Math.max(maxArea, (right - left + 1) * height);
}
```

### 单调栈

「[42](https://leetcode-cn.com/problems/trapping-rain-water/). 接雨水」同样用到单调栈。

[官方题解](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/zhu-zhuang-tu-zhong-zui-da-de-ju-xing-by-leetcode-/)：维护正反单调栈，维护栈的同时把每个柱子的左右边界（左边和右边第一个小于当前柱子高度的 index）存到数组中。正在遍历的 i 是当前柱子；正向栈中的栈顶元素是「左边第一个小于当前柱子的柱体」；反向栈中的栈顶元素是「右边第一个小于当前柱子的柱体」，具体进链接。

甜姨的[题解](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/solution/xiang-jie-dan-diao-zhan-bi-xu-miao-dong-by-sweetie/)：只维护一个单调栈。栈顶元素为当前柱子，正在遍历的第 i 根柱子为「右边第一个小于当前柱子的柱体」；栈顶的下一个元素为「左边第一个小于当前柱子的柱体」，具体进链接。


## 29. ⭐ 对称二叉树

!> [101](https://leetcode-cn.com/problems/symmetric-tree/). 对称二叉树

> 不太会写

### 递归

```java
public static boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    return DFS(root.left, root.right);
}
private static boolean DFS(TreeNode p, TreeNode q) {
    if (p == null && q == null) {
        return true;
    }
    if (p == null || q == null || p.val != q.val) {
        return false;
    }
    // 比较 p 的左子树与 q 的右子树是否对称，p 的右子树与 q 的左子树是否对称
    return DFS(p.left, q.right) && DFS(p.right, q.left);
}
```

### 迭代

```java
public static boolean isSymmetric(TreeNode root) {
    if (root == null) {
        return true;
    }
    Queue<TreeNode> queue = new LinkedList<>();
    queue.add(root.left);
    queue.add(root.right);
    
    while (!queue.isEmpty()) {
        TreeNode p = queue.poll();
        TreeNode q = queue.poll();
        if (q == null && p == null) {
            continue;
        }
        if ((p == null || q == null) || (p.val != q.val)) {
            return false;
        }
        queue.add(p.left);
        queue.add(q.right);
        queue.add(p.right);
        queue.add(q.left);
    }
    return true;
}
```